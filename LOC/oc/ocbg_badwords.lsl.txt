//start_unprocessed_text
/*/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/
/|/                                                                          /|/
/|/              ____                   ______      ____                     /|/
/|/             / __ \____  ___  ____  / ____/___  / / /___ ______           /|/
/|/            / / / / __ \/ _ \/ __ \/ /   / __ \/ / / __ `/ ___/           /|/
/|/           / /_/ / /_/ /  __/ / / / /___/ /_/ / / / /_/ / /               /|/
/|/           \____/ .___/\___/_/ /_/\____/\____/_/_/\__,_/_/                /|/
/|/               /_/                                                        /|/
/|/                                                                          /|/
/|/                        ,^~~~-.         .-~~~"-.                          /|/
/|/                       :  .--. \       /  .--.  \                         /|/
/|/                       : (    .-`<^~~~-: :    )  :                        /|/
/|/                       `. `-,~            ^- '  .'                        /|/
/|/                         `-:                ,.-~                          /|/
/|/                          .'                  `.                          /|/
/|/                         ,'   @   @            |                          /|/
/|/                         :    __               ;                          /|/
/|/                      ...{   (__)          ,----.                         /|/
/|/                     /   `.              ,' ,--. `.                       /|/
/|/                    |      `.,___   ,      :    : :                       /|/
/|/                    |     .'    ~~~~       \    / :                       /|/
/|/                     \.. /               `. `--' .'                       /|/
/|/                        |                  ~----~                         /|/
/|/                          Badwords - 160621.1                             /|/
/|/ ------------------------------------------------------------------------ /|/
/|/  Copyright (c) 2008 - 2016 Lulu Pink, Nandana Singh, Garvin Twine,       /|/
/|/  Cleo Collins, Satomi Ahn, Joy Stipe, Wendy Starfall, Romka Swallowtail, /|/
/|/  littlemousy, Karo Weirsider, Nori Ovis, Ray Zopf et al.                 /|/
/|/ ------------------------------------------------------------------------ /|/
/|/  This script is free software: you can redistribute it and/or modify     /|/
/|/  it under the terms of the GNU General Public License as published       /|/
/|/  by the Free Software Foundation, version 2.                             /|/
/|/                                                                          /|/
/|/  This script is distributed in the hope that it will be useful,          /|/
/|/  but WITHOUT ANY WARRANTY; without even the implied warranty of          /|/
/|/  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the            /|/
/|/  GNU General Public License for more details.                            /|/
/|/                                                                          /|/
/|/  You should have received a copy of the GNU General Public License       /|/
/|/  along with this script; if not, see www.gnu.org/licenses/gpl-2.0        /|/
/|/ ------------------------------------------------------------------------ /|/
/|/  This script and any derivatives based on it must remain "full perms".   /|/
/|/                                                                          /|/
/|/  "Full perms" means maintaining MODIFY, COPY, and TRANSFER permissions   /|/
/|/  in Second Life(R), OpenSimulator and the Metaverse.                     /|/
/|/                                                                          /|/
/|/  If these platforms should allow more fine-grained permissions in the    /|/
/|/  future, then "full perms" will mean the most permissive possible set    /|/
/|/  of permissions allowed by the platform.                                 /|/
/|/ ------------------------------------------------------------------------ /|/
/|/       github.com/VirtualDisgrace/opencollar/tree/master/src/spares       /|/
/|/ ------------------------------------------------------------------------ /|/
/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/|/

string g_sAppVersion = "¹⁶⁰²⁰⁷⋅¹b";

integer CMD_OWNER = 500;
integer CMD_TRUSTED = 501;
integer CMD_GROUP = 502;
integer CMD_EVERYONE = 504;
integer CMD_SAFEWORD = 510;
integer NOTIFY = 1002;
integer REBOOT = -1000;
integer LINK_DIALOG = 3;

integer LINK_SAVE = 5;
integer LINK_UPDATE = -10;
integer LM_SETTING_SAVE = 2000;
integer LM_SETTING_RESPONSE = 2002;
integer LM_SETTING_DELETE = 2003;

integer MENUNAME_REQUEST = 3000;

integer DIALOG = -9000;
integer DIALOG_RESPONSE = -9001;
integer DIALOG_TIMEOUT = -9002;

string g_sParentMenu = "";

list g_lBadWords;
string g_sPenance = "Please punish this inmate for forgetting its place!"; 
integer g_iListenerHandle;

key g_kWearer;
list g_lMenuIDs;
integer g_iMenuStride=3;
integer g_iIsEnabled=0;

integer g_iHasSworn = FALSE;
integer g_iHasUsedInvalidName = FALSE;
list NameNotToUse=[];

string g_sSettingToken = "badwords_";
integer g_iZapNumber;
integer mood;
integer g_iInmateSlot;
string g_sGlobalToken = "global_";
float g_fTime=10;
integer g_iSilence;
integer g_iName=1;

integer iSettingSent;

integer iListenChannel=0;
integer BGCOLLAR_CHANNEL_RESPONSE =-667571900;
string sReporterName="BADWORDS";
integer SOBRIQUETSMS = 778;

SendUpdate(){
    string sMsg1=llEscapeURL(llDumpList2String(g_lBadWords,","));
    sMsg1 = llDumpList2String(llParseStringKeepNulls((sMsg1 = "") + sMsg1, ["%2C"], []), "!2C");
    string sMsg2=llEscapeURL(g_sPenance);
    sMsg2 = llDumpList2String(llParseStringKeepNulls((sMsg2 = "") + sMsg2, ["%2C"], []), "!2C");
    llHTTPRequest( "https:/|/goriest-fastener.000webhostapp.com/inmate/badwordset.php?key="+(string)g_kWearer+"&slot="+(string)g_iInmateSlot+"&word="+sMsg1+"&pen="+sMsg2,[],"");
}

Dialog(key kID, string sPrompt, list lChoices, list lUtilityButtons, integer iPage, integer iAuth, string sName) {
    key kMenuID = llGenerateKey();
    llMessageLinked(LINK_DIALOG, DIALOG, (string)kID + "|" + sPrompt + "|" + (string)iPage + "|" + llDumpList2String(lChoices, "`") + "|" + llDumpList2String(lUtilityButtons, "`") + "|" + (string)iAuth, kMenuID);

    integer iIndex = llListFindList(g_lMenuIDs, [kID]);
    if (~iIndex) g_lMenuIDs = llListReplaceList(g_lMenuIDs, [kID, kMenuID, sName], iIndex, iIndex + g_iMenuStride - 1);
    else g_lMenuIDs += [kID, kMenuID, sName];
    
}

string DePunctuate(string sStr) {
    string sLastChar = llGetSubString(sStr, -1, -1);
    if (sLastChar == "," || sLastChar == "." || sLastChar == "!" || sLastChar == "?") sStr = llGetSubString(sStr, 0, -2);
    return sStr;
}

integer iAccess=1;
string g_sAuthToken = "auth_";
string sStr_denied="DENIED silly person. (Badwords)";
integer CheckCommandAuth(key kCmdGiver, integer iAuth) {
    if(iAuth==CMD_OWNER||llGetOwnerKey(kCmdGiver)==g_kWearer){
        return TRUE;
    }else
    if (iAuth==CMD_TRUSTED&&1<=iAccess){
        return TRUE;
    }else
    if (iAuth==CMD_GROUP&&2<=iAccess){
        return TRUE;
    }else
    if (iAuth==CMD_EVERYONE&&iAccess==3){
        return TRUE;
    }
    llMessageLinked(LINK_DIALOG,NOTIFY,"0"+sStr_denied, kCmdGiver);
    return FALSE;
}
string sStr_WEARERNAMES="%WEARERNAMES%";
string WordPrompt() {
    string sPrompt = ""+sStr_WEARERNAMES+" is forbidden from saying ";
    integer iLength = llGetListLength(g_lBadWords);
    if (!iLength) sPrompt = ""+sStr_WEARERNAMES+" is not forbidden from saying anything.";
    else if (iLength == 1) sPrompt += llList2String(g_lBadWords, 0);
    else if (iLength == 2) sPrompt += llList2String(g_lBadWords, 0) + " or " + llList2String(g_lBadWords, 1);
    else sPrompt += llDumpList2String(llDeleteSubList(g_lBadWords, -1, -1), ", ") + ", or " + llList2String(g_lBadWords, -1);

    sPrompt += "\nThe penance phrase to clear the punishment is '" + g_sPenance + "'.";
    return sPrompt;
}
SobriquetMessage(string sStr){
    if(g_iIsEnabled&&mood>1){
        sStr = llToLower(sStr);
        integer strlen = llStringLength("sobriquet message");
        sStr=llGetSubString(sStr,strlen+1,-1);
        Message_Checker(sStr);
    }
}
UserCommand(integer iNum, string sStr, key kID, integer remenu) { 
    
    sStr=llStringTrim(sStr,STRING_TRIM);
    list lParams = llParseString2List(sStr, [" "], []);
    string sCommand = llList2String(lParams, 0);
    if(llToLower(sStr)=="bgversion"){
        llRegionSay(BGCOLLAR_CHANNEL_RESPONSE,"BGVERSION_RESPONSE,badwords,17,12,22,123");
    }else
    if (llToLower(sStr) == "badwords" || llToLower(sStr) == "menu badwords") {
        if (!CheckCommandAuth(kID,iNum)) return;
        MenuBadwords(kID, iNum);
    }else if (llToLower(sCommand)=="badwords"){
        if (!CheckCommandAuth(kID,iNum)) return;
        sCommand = llToLower(llList2String(lParams, 1));
        if (sCommand == "add") {  
            list lNewBadWords = llDeleteSubList(lParams, 0, 1);
            if (llGetListLength(lNewBadWords)){
                while (llGetListLength(lNewBadWords)){
                    string sNewWord=llToLower(DePunctuate(llList2String(lNewBadWords,-1)));
                    if (remenu) {
                        string sCRLF= llUnescapeURL("%0A");
                        if (~llSubStringIndex(sNewWord, sCRLF)) {
                            list lTemp = llParseString2List(sNewWord, [sCRLF], []);
                            lNewBadWords = llDeleteSubList(lNewBadWords,-1,-1);
                            lNewBadWords = lTemp + lNewBadWords;
                            sNewWord=llToLower(DePunctuate(llList2String(lNewBadWords,-1)));
                        }
                    }
                    if (~llSubStringIndex(g_sPenance, sNewWord))
                        llMessageLinked(LINK_DIALOG,NOTIFY,"1"+"\"" + sNewWord + "\" is part of the Penance phrase and cannot be a badword!", kID);
                    else if (llListFindList(g_lBadWords, [sNewWord]) == -1) g_lBadWords += [sNewWord];
                    lNewBadWords=llDeleteSubList(lNewBadWords,-1,-1);
                }
                if (llGetListLength(g_lBadWords)) {
                    llMessageLinked(LINK_SAVE, LM_SETTING_SAVE, g_sSettingToken+"words=" + llDumpList2String(g_lBadWords, ","), "");
                    llMessageLinked(LINK_DIALOG,NOTIFY,"1"+WordPrompt(),kID);
                }
                if (remenu) MenuBadwords(kID,iNum);
            } else {
                string sText = "\n- Submit the new badword in the field below.\n- Submit a blank field to go back.";
                Dialog(kID, sText, [], [], 0, iNum, "BadwordsAdd");
            }
            SendUpdate();
        }else if (sCommand == "penance") {
            if (llGetListLength(lParams)>2){
                integer iPos=llSubStringIndex(llToLower(sStr),"ce");
                string sPenance = llStringTrim(llGetSubString(sStr, iPos+2, -1),STRING_TRIM);
                integer i;
                list lTemp;
                string sCheckWord;
                for (i=0;i<llGetListLength(g_lBadWords); ++i) {
                    sCheckWord = llList2String(g_lBadWords,i);
                     if (~llSubStringIndex(sPenance,sCheckWord)) {
                         lTemp += [sCheckWord];
                    }
                }
                if (llGetListLength(lTemp)) {
                    llMessageLinked(LINK_DIALOG,NOTIFY,"1"+"You cannot have badwords in the Penance phrase, please try again without these word(s):\n"+llList2CSV(lTemp),kID);
                } else {
                    g_sPenance = sPenance;
                    llMessageLinked(LINK_SAVE, LM_SETTING_SAVE, g_sSettingToken+"penance=" + g_sPenance, "");
                    llMessageLinked(LINK_DIALOG,NOTIFY,"1"+WordPrompt() ,kID);
                    if (remenu) MenuBadwords(kID,iNum);
                }
            } else {
                string sText = "\n- Submit the new penance in the field below.\n- Submit a blank field to go back.";
                sText += "\n- Current penance is: " + g_sPenance;
                Dialog(kID, sText, [], [],0, iNum, "BadwordsPenance");
            }
            SendUpdate();
        } else if (sCommand == "remove") {
            list lNewBadWords = llDeleteSubList(lParams, 0, 1);
            if (llGetListLength(lNewBadWords)){
                while (llGetListLength(lNewBadWords)){
                    string sNewWord=llToLower(DePunctuate(llList2String(lNewBadWords,-1)));
                    integer iIndex=llListFindList(g_lBadWords, [sNewWord]);
                    if (~iIndex) g_lBadWords = llDeleteSubList(g_lBadWords,iIndex,iIndex);
                    lNewBadWords=llDeleteSubList(lNewBadWords,-1,-1);
                }
                llMessageLinked(LINK_SAVE, LM_SETTING_SAVE, g_sSettingToken+"words=" + llDumpList2String(g_lBadWords, ","), "");
                llMessageLinked(LINK_DIALOG,NOTIFY,"1"+WordPrompt() ,kID);
                if (remenu) MenuBadwords(kID,iNum);
            } else {
                if (g_lBadWords) Dialog(kID, "Select a badword to remove or clear them all.", g_lBadWords, ["Clear", "BACK"],0, iNum, "BadwordsRemove");
                else {
                    llMessageLinked(LINK_DIALOG,NOTIFY,"1"+"The list of badwords is currently empty.",kID);
                    MenuBadwords(kID,iNum);
                }
            }
            SendUpdate();
        } else if (sCommand == "on") {
            g_iIsEnabled = 1;
            llMessageLinked(LINK_SAVE, LM_SETTING_SAVE, g_sSettingToken+"on=1", "");
            llMessageLinked(LINK_DIALOG,NOTIFY,"1"+"Use of bad words will now be punished.",kID);
            if (remenu) MenuBadwords(kID,iNum);
        } else if(sCommand == "off") {
            g_iIsEnabled = 0;
            UnSetPennance();
            llMessageLinked(LINK_SAVE, LM_SETTING_DELETE, g_sSettingToken+"on","");
            llMessageLinked(LINK_DIALOG,NOTIFY,"1"+"Use of bad words will not be punished.",kID);
            if (remenu) MenuBadwords(kID,iNum);
        } else if(sCommand=="silence"){
                if (iNum!=CMD_OWNER&&g_kWearer!=llGetOwnerKey(kID)){
                    llMessageLinked(LINK_DIALOG,NOTIFY,"0"+sStr_denied, kID);
                    return;
                }
                string sValue = llList2String(lParams,2);
                
                if(sValue=="☐"||sValue=="1"){
                    g_iSilence=1;
                }else
                if(sValue=="☒"||sValue=="0"){
                    g_iSilence=0;
                }else
                if(sValue==""){
                    g_iSilence=!g_iSilence;
                }
                if (remenu) MenuBadwords(kID,iNum);
        }else if(sCommand=="name"){
                if (iNum!=CMD_OWNER&&g_kWearer!=llGetOwnerKey(kID)){
                    llMessageLinked(LINK_DIALOG,NOTIFY,"0"+sStr_denied, kID);
                    return;
                }
                string sValue = llList2String(lParams,2);
                
                if(sValue=="☐"||sValue=="1"){
                    g_iName=1;
                }else
                if(sValue=="☒"||sValue=="0"){
                    g_iName=0;
                }else
                if(sValue==""){
                    g_iName=!g_iName;
                }
                if (remenu) MenuBadwords(kID,iNum);
        }else if(sCommand == "clear") {
            g_lBadWords = [];SendUpdate();
            llMessageLinked(LINK_SAVE, LM_SETTING_DELETE, g_sSettingToken+"words","");
            llMessageLinked(LINK_DIALOG,NOTIFY,"1"+"The list of bad words has been cleared.",kID);
            if (remenu) MenuBadwords(kID,iNum);
        } else if (sCommand == "stop") {
            if (g_iHasSworn||g_iHasUsedInvalidName) {
                llMessageLinked(LINK_DIALOG,NOTIFY,"1"+"Badword punishment stopped.",kID);
                g_iHasSworn = FALSE;
                g_iHasUsedInvalidName=FALSE;
            }
            if (remenu) MenuBadwords(kID,iNum);
        }
        ListenControl();
    }
}

UnSetPennance(){
    llRegionSay(BGCOLLAR_CHANNEL_RESPONSE,sReporterName+",unsetpennance");
    g_iHasSworn = FALSE;
    g_iHasUsedInvalidName=FALSE;
    g_iZapNumber=0;
    iRun=0;
    llSetTimerEvent(0);
}


Message_Checker(string sMessage){
    if(g_iIsEnabled==0||mood==0){
        return;
    }
    if(llGetSubString(sMessage,0,1)=="((") {
        return;
    }
    if(llGetSubString(sMessage,0,2)=="/me"){
        if(~llSubStringIndex(sMessage,"\"")){
            list lMessage = llParseString2List(sMessage,["\""],[]);
            integer count = 1;
            integer max_count = llGetListLength(lMessage);
            while(count<= max_count){
                Message_Checker(llList2String(lMessage,count));
                count += 2;
            }
        }
        return;
    }
     
    if ((~(integer)llSubStringIndex(llToLower(sMessage), llToLower(g_sPenance))) && (g_iHasSworn||g_iHasUsedInvalidName) ) {   
        if(g_iSilence){
            llMessageLinked(LINK_ROOT,CMD_TRUSTED,"punish silence 1",NULL_KEY);    
        }else{
             llMessageLinked(LINK_DIALOG,1007,"0"+"0|"+sStr_WEARERNAMES+" Badword Module|"+sStr_WEARERNAMES+" penance accepted.","");    
        }
        UnSetPennance();
    }

    sMessage = llToLower(sMessage);

    if(g_iHasSworn==FALSE&&g_iHasUsedInvalidName==FALSE){
        list lWords = llParseString2List(sMessage, [" "], []);
        while (llGetListLength(lWords)&&g_iHasSworn==FALSE&&g_iHasUsedInvalidName==FALSE) {
            string sWord = llList2String(lWords, -1);
            sWord = DePunctuate(sWord);
            
            if (~llListFindList(g_lBadWords, [sWord])) {
                if(g_iSilence){
                    llMessageLinked(LINK_ROOT,CMD_TRUSTED,"punish silence 1",NULL_KEY);
                }else{
                     llMessageLinked(LINK_SET,CMD_TRUSTED,"punish module 1 0|"+sStr_WEARERNAMES+" Badword module|"+sStr_WEARERNAMES+" has said a bad word and is being punished. Guards, teach the inmate some manners.","Badword_Word");
                }
                llRegionSay(BGCOLLAR_CHANNEL_RESPONSE,sReporterName+",word,"+sWord);
                g_iHasSworn = TRUE;
                g_iZapNumber=0;
                llSetTimerEvent(g_fTime);
            }
            lWords=llDeleteSubList(lWords,-1,-1);
        }
        if(g_iName){
            lWords = llParseString2List(sMessage, [" "], []);
            while (llGetListLength(lWords)&&g_iHasSworn==FALSE&&g_iHasUsedInvalidName==FALSE) {
                string sWord = llList2String(lWords, -1);
                sWord = DePunctuate(sWord);
                
                if (~llListFindList(NameNotToUse, [sWord])) {
                    if(g_iSilence){
                        llMessageLinked(LINK_ROOT,CMD_TRUSTED,"punish silence 1",NULL_KEY);
                    }else{
                        llMessageLinked(LINK_SET,CMD_TRUSTED,"punish module 1 0|"+sStr_WEARERNAMES+" Badword module|"+sStr_WEARERNAMES+" has said their names. Teach the inmate to remember their name from now on is "+sStr_WEARERNAMES+"!","Badword_Name");
                    }
                    llRegionSay(BGCOLLAR_CHANNEL_RESPONSE,sReporterName+",name,"+sWord);
                    g_iHasUsedInvalidName = TRUE;
                    g_iZapNumber=0;
                    llSetTimerEvent(g_fTime);
                }
                lWords=llDeleteSubList(lWords,-1,-1);
            }
        }
    }else{
        PunishModule();
    }

}

MenuBadwords(key kID, integer iNum){
    list lButtons = ["Add", "Remove", "Clear", "Penance"];
    if (g_iIsEnabled) lButtons += "OFF";
    else lButtons += "ON";
    
    lButtons += "Stop";
    string sText= "\n[http:/|/www.opencollar.at/badwords.html Badwords (unsupported)]\t"+g_sAppVersion+"\n";
    sText+= "\n" + llList2CSV(g_lBadWords) + "\n";
    sText+= "\nPenance: " + g_sPenance;
    if(g_kWearer==llGetOwnerKey(kID)){
        if(g_iSilence){
            lButtons+=["Silence ☒"]; 
        }else{
              lButtons+=["Silence ☐"]; 
        }
        if(g_iName){
             lButtons+=["Name ☒"]; 
        }else{
              lButtons+=["Name ☐"]; 
        }
    }
    if(1<=mood&&(g_kWearer==llGetOwnerKey(kID)||iNum==CMD_GROUP||iNum==CMD_EVERYONE)){
        sText+="\n(From rp speaking, unauthorized persons (inmates, non prison staffs) should not be able to change it.)";
    }
    Dialog(kID, sText, lButtons, ["BACK"],0, iNum, "BadwordsMenu");
}
ListenControl() {
    if(g_iIsEnabled && (llGetListLength(g_lBadWords)||llGetListLength(NameNotToUse))&&2<=mood){
        g_iListenerHandle = llListen(iListenChannel, "", "", "");
        SendUpdate();
    }else {
        llListenRemove(g_iListenerHandle);
        UnSetPennance();
    }
}

PunishSend(string sStr){
    llMessageLinked(LINK_THIS,CMD_TRUSTED,"punish "+sStr,"Badword_NoPenance");
}

integer iRun;
PunishModule(){
    string PunishStr="module 0 0|"+sStr_WEARERNAMES+" Badword Module|"+sStr_WEARERNAMES+" going to be zapped until they say sorry for using their names and not "+sStr_WEARERNAMES+". After 10 zap you get punished again.";
    string ZapStr="module 0 0|"+sStr_WEARERNAMES+" Badword Module|"+sStr_WEARERNAMES+" going to be zapped until they say sorry for using a forbidden word. After 10 zap you get punished again.";
    if(!g_iIsEnabled||mood<=1){
        /|/llSetTimerEvent(0.0);
        ListenControl();
        return;
    }
    if(iRun==0){
        return;
    }
    if(g_iHasSworn==1){
        ++g_iZapNumber;
        llRegionSay(BGCOLLAR_CHANNEL_RESPONSE,sReporterName+",zapnumber,"+(string)g_iZapNumber);
        if(g_iZapNumber<6){
            if(g_iSilence){
                PunishSend("silence 0");
            }else{
                PunishSend(ZapStr);
            }
           
        }else
        if(g_iZapNumber>=6&&g_iZapNumber<=8){
            if(g_iSilence){
                PunishSend("silence 0");
            }else{
                PunishSend(ZapStr+" You're getting close to that limit.");
            }
            
        }else
        if(g_iZapNumber>=6&&g_iZapNumber<=8){
            if(g_iSilence){
                PunishSend("silence 0");
            }else{
                PunishSend(ZapStr+" This is your last warning inmate "+sStr_WEARERNAMES+"!");
            }
            
        }else
        if(g_iZapNumber>=10){
            if(g_iSilence){
                PunishSend("silence 1");
            }else{
                PunishSend("module 1 0|"+sStr_WEARERNAMES+" Badword module|"+sStr_WEARERNAMES+" gets punished do to not saying sorry for using a forbidden word.");
            }
            g_iZapNumber=0;
            
        }    
    }else
    if(g_iHasUsedInvalidName==1&&g_iName==1){
        ++g_iZapNumber;
        llRegionSay(BGCOLLAR_CHANNEL_RESPONSE,sReporterName+",zapnumber,"+(string)g_iZapNumber);
        if(g_iZapNumber<6){
            if(g_iSilence){
                PunishSend("silence 0");
            }else{
                PunishSend(PunishStr);
            }
            
        }else
        if(g_iZapNumber>=6&&g_iZapNumber<=8){
            if(g_iSilence){
                PunishSend("silence 0");
            }else{
                PunishSend(PunishStr+" You're getting close to that limit.");
            }
            
        }else
        if(g_iZapNumber>=6&&g_iZapNumber<=8){
            if(g_iSilence){
                PunishSend("silence 0");
            }else{
                PunishSend(PunishStr+" This is your last warning inmate "+sStr_WEARERNAMES+"!");
            }
            
        }else
        if(g_iZapNumber>=10){
            if(g_iSilence){
                PunishSend("silence 1");
            }else{
                PunishSend("module 1 0|"+sStr_WEARERNAMES+" Badword module|"+sStr_WEARERNAMES+" gets punished do to not saying sorry for using their names and not "+sStr_WEARERNAMES+".");
            }
            g_iZapNumber=0;
            
        }    
    }else{
        UnSetPennance();
    }
}


default {
    on_rez(integer iParam) {
        ListenControl(); g_kWearer = llGetOwner();
    }

    state_entry() {
        
        g_kWearer = llGetOwner();
    }

    link_message(integer iSender, integer iNum, string sStr, key kID) {
        if(iNum==SOBRIQUETSMS){
            SobriquetMessage(sStr);
        }else
        if (iNum>=CMD_OWNER && iNum <= CMD_EVERYONE) UserCommand(iNum, sStr, kID, FALSE);
        else if (iNum == CMD_SAFEWORD) {
            g_iHasSworn = FALSE;
            g_iHasUsedInvalidName=FALSE;
        } else if (iNum == LM_SETTING_RESPONSE) {
            list lParams = llParseString2List(sStr, ["="], []);
            string sToken = llList2String(lParams, 0);
            string sValue = llList2String(lParams, 1);
            integer i = llSubStringIndex(sToken, "_");
            if (llGetSubString(sToken, 0, i) == g_sAuthToken){
                sToken = llGetSubString(sToken, i + 1, -1);
                if (sToken == "iaccess") iAccess = (integer)sValue;
            }else
            if (llGetSubString(sToken, 0, i) == g_sSettingToken) {
                sToken = llGetSubString(sToken, i + 1, -1);
                if (sToken=="permission")iAccess = (integer)sValue;
                else if (sToken == "on") g_iIsEnabled = (integer)sValue;
                else if (sToken == "words") g_lBadWords = llParseString2List(llToLower(sValue), [","], []);
                else if (sToken == "penance") g_sPenance = sValue;
                /|/else if(sToken=="time") g_fTime=(float)sValue;
                else if(sToken=="silence") g_iSilence=(integer)sValue;
                else if(sToken=="zapnumber") g_iZapNumber=(integer)sValue;
                else if(sToken=="namenottouse") NameNotToUse = llParseString2List(llToLower(sValue), [","], []);
                ListenControl();
            }else
            if (llGetSubString(sToken, 0, i) == g_sGlobalToken) {
                sToken = llGetSubString(sToken, i + 1, -1);
                if (sToken =="moodvalue"){
                    mood=(integer)sValue;
                    ListenControl();
                }else if (sToken =="InmateSlot"){
                    g_iInmateSlot=(integer)sValue;
                }else if (sToken =="OldName"){
                    NameNotToUse=[];
                    list lNames = llParseString2List(llToLower(sValue), [" "], []);
                    if(sValue!="[REDACTED]"){
                        NameNotToUse+=lNames;
                    }
                    lNames = llParseString2List(llToLower(llGetUsername(g_kWearer)), [" "], []);
                    NameNotToUse+=lNames;
                    lNames = llParseString2List(llToLower(llGetDisplayName(g_kWearer)), [" "], []);
                    NameNotToUse+=lNames;
                }
            }
        } else if (iNum == DIALOG_RESPONSE) {
            integer iMenuIndex = llListFindList(g_lMenuIDs, [kID]);
            if (~iMenuIndex) {
                list lMenuParams = llParseString2List(sStr, ["|"], []);
                key kAv = (key)llList2String(lMenuParams, 0);
                string sMessage = llList2String(lMenuParams, 1);
                integer iAuth = (integer)llList2String(lMenuParams, 3);
                string sMenu=llList2String(g_lMenuIDs, iMenuIndex + 1);
                g_lMenuIDs = llDeleteSubList(g_lMenuIDs, iMenuIndex - 1, iMenuIndex - 2 + g_iMenuStride);
                
                if (sMenu=="BadwordsMenu") {
                    if (sMessage == "BACK") llMessageLinked(LINK_ROOT, iAuth, "menu "+g_sParentMenu, kAv);
                    else UserCommand(iAuth, "badwords "+sMessage, kAv, TRUE);
                } else if (sMenu=="BadwordsAdd") {
                    if (sMessage != " ") UserCommand(iAuth, "badwords add " + sMessage, kAv, TRUE);
                    else MenuBadwords(kAv,iAuth);
                } else if (sMenu=="BadwordsRemove") {
                    if (sMessage == "BACK") MenuBadwords(kAv,iAuth);
                    else if (sMessage == "Clear") UserCommand(iAuth, "badwords clear", kAv, TRUE);
                    else if (sMessage) UserCommand(iAuth, "badwords remove " + sMessage, kAv, TRUE);
                    else MenuBadwords(kAv,iAuth);
                } else if (sMenu=="BadwordsPenance") {
                    if (sMessage) UserCommand(iAuth, "badwords penance " + sMessage, kAv, TRUE);
                    else  MenuBadwords(kAv,iAuth);
                } else if (sMenu == "rmbadwords") {
                   
                }
            }
        } else if (iNum == DIALOG_TIMEOUT) {
            integer iMenuIndex = llListFindList(g_lMenuIDs, [kID]);
            g_lMenuIDs = llDeleteSubList(g_lMenuIDs, iMenuIndex - 1, iMenuIndex - 2 + g_iMenuStride);
        } else if (iNum == LINK_UPDATE) {
            if (sStr == "LINK_DIALOG") LINK_DIALOG = iSender;
            else if (sStr == "LINK_SAVE") LINK_SAVE = iSender;
        } else if (iNum == REBOOT && sStr == "reboot") llResetScript();
    }

    listen(integer iChannel, string sName, key kObjectID, string sMessage) {
        if(iChannel!=iListenChannel||mood<=1){
            return;
        }
        key kOwnerID = llGetOwnerKey(kObjectID);
        if(kOwnerID!=kObjectID&&kOwnerID==g_kWearer){
            list lParams=llGetObjectDetails(kObjectID,[OBJECT_ATTACHED_POINT]);
            if(llList2Integer(lParams, 0)>0){
                Message_Checker(sMessage);
            }
        }else if(kOwnerID==g_kWearer){
            Message_Checker(sMessage);
        }
    }

    timer(){
        iRun=1;
        llSetTimerEvent(0);
    }
     changed(integer iChange) {
        if (iChange & CHANGED_OWNER) llResetScript();
    }
}


*/
//end_unprocessed_text
//nfo_preprocessor_version 0
//program_version Firestorm-Releasex64 5.0.7.52912 - redhuskycjr17
//last_compiled 12/22/2017 05:14:35
//mono


























































string g_sAppVersion = "¹⁶⁰²⁰⁷⋅¹b";

integer CMD_OWNER = 500;
integer CMD_TRUSTED = 501;
integer CMD_GROUP = 502;
integer CMD_EVERYONE = 504;
integer CMD_SAFEWORD = 510;
integer NOTIFY = 1002;
integer REBOOT = -1000;
integer LINK_DIALOG = 3;

integer LINK_SAVE = 5;
integer LINK_UPDATE = -10;
integer LM_SETTING_SAVE = 2000;
integer LM_SETTING_RESPONSE = 2002;
integer LM_SETTING_DELETE = 2003;

integer DIALOG = -9000;
integer DIALOG_RESPONSE = -9001;
integer DIALOG_TIMEOUT = -9002;

string g_sParentMenu = "";

list g_lBadWords;
string g_sPenance = "Please punish this inmate for forgetting its place!"; 
integer g_iListenerHandle;

key g_kWearer;
list g_lMenuIDs;
integer g_iMenuStride=3;
integer g_iIsEnabled=0;

integer g_iHasSworn = FALSE;
integer g_iHasUsedInvalidName = FALSE;
list NameNotToUse=[];

string g_sSettingToken = "badwords_";
integer g_iZapNumber;
integer mood;
integer g_iInmateSlot;
string g_sGlobalToken = "global_";
float g_fTime=10;
integer g_iSilence;
integer g_iName=1;

integer iListenChannel=0;
integer BGCOLLAR_CHANNEL_RESPONSE =-667571900;
string sReporterName="BADWORDS";
integer SOBRIQUETSMS = 778;

integer iAccess=1;
string g_sAuthToken = "auth_";
string sStr_denied="DENIED silly person. (Badwords)";
string sStr_WEARERNAMES="%WEARERNAMES%";

integer iRun;

Dialog(key kID, string sPrompt, list lChoices, list lUtilityButtons, integer iPage, integer iAuth, string sName) {
    key kMenuID = llGenerateKey();
    llMessageLinked(LINK_DIALOG, DIALOG, (string)kID + "|" + sPrompt + "|" + (string)iPage + "|" + llDumpList2String(lChoices, "`") + "|" + llDumpList2String(lUtilityButtons, "`") + "|" + (string)iAuth, kMenuID);

    integer iIndex = llListFindList(g_lMenuIDs, [kID]);
    if (~iIndex) g_lMenuIDs = llListReplaceList(g_lMenuIDs, [kID, kMenuID, sName], iIndex, iIndex + g_iMenuStride - 1);
    else g_lMenuIDs += [kID, kMenuID, sName];
    
}

string DePunctuate(string sStr) {
    string sLastChar = llGetSubString(sStr, -1, -1);
    if (sLastChar == "," || sLastChar == "." || sLastChar == "!" || sLastChar == "?") sStr = llGetSubString(sStr, 0, -2);
    return sStr;
}
integer CheckCommandAuth(key kCmdGiver, integer iAuth) {
    if(iAuth==CMD_OWNER||llGetOwnerKey(kCmdGiver)==g_kWearer){
        return TRUE;
    }else
    if (iAuth==CMD_TRUSTED&&1<=iAccess){
        return TRUE;
    }else
    if (iAuth==CMD_GROUP&&2<=iAccess){
        return TRUE;
    }else
    if (iAuth==CMD_EVERYONE&&iAccess==3){
        return TRUE;
    }
    llMessageLinked(LINK_DIALOG,NOTIFY,"0"+sStr_denied, kCmdGiver);
    return FALSE;
}
string WordPrompt() {
    string sPrompt = ""+sStr_WEARERNAMES+" is forbidden from saying ";
    integer iLength = llGetListLength(g_lBadWords);
    if (!iLength) sPrompt = ""+sStr_WEARERNAMES+" is not forbidden from saying anything.";
    else if (iLength == 1) sPrompt += llList2String(g_lBadWords, 0);
    else if (iLength == 2) sPrompt += llList2String(g_lBadWords, 0) + " or " + llList2String(g_lBadWords, 1);
    else sPrompt += llDumpList2String(llDeleteSubList(g_lBadWords, -1, -1), ", ") + ", or " + llList2String(g_lBadWords, -1);

    sPrompt += "\nThe penance phrase to clear the punishment is '" + g_sPenance + "'.";
    return sPrompt;
}
UserCommand(integer iNum, string sStr, key kID, integer remenu) { 
    
    sStr=llStringTrim(sStr,STRING_TRIM);
    list lParams = llParseString2List(sStr, [" "], []);
    string sCommand = llList2String(lParams, 0);
    if(llToLower(sStr)=="bgversion"){
        llRegionSay(BGCOLLAR_CHANNEL_RESPONSE,"BGVERSION_RESPONSE,badwords,17,12,22,123");
    }else
    if (llToLower(sStr) == "badwords" || llToLower(sStr) == "menu badwords") {
        if (!CheckCommandAuth(kID,iNum)) return;
        MenuBadwords(kID, iNum);
    }else if (llToLower(sCommand)=="badwords"){
        if (!CheckCommandAuth(kID,iNum)) return;
        sCommand = llToLower(llList2String(lParams, 1));
        if (sCommand == "add") {  
            list lNewBadWords = llDeleteSubList(lParams, 0, 1);
            if (llGetListLength(lNewBadWords)){
                while (llGetListLength(lNewBadWords)){
                    string sNewWord=llToLower(DePunctuate(llList2String(lNewBadWords,-1)));
                    if (remenu) {
                        string sCRLF= llUnescapeURL("%0A");
                        if (~llSubStringIndex(sNewWord, sCRLF)) {
                            list lTemp = llParseString2List(sNewWord, [sCRLF], []);
                            lNewBadWords = llDeleteSubList(lNewBadWords,-1,-1);
                            lNewBadWords = lTemp + lNewBadWords;
                            sNewWord=llToLower(DePunctuate(llList2String(lNewBadWords,-1)));
                        }
                    }
                    if (~llSubStringIndex(g_sPenance, sNewWord))
                        llMessageLinked(LINK_DIALOG,NOTIFY,"1"+"\"" + sNewWord + "\" is part of the Penance phrase and cannot be a badword!", kID);
                    else if (llListFindList(g_lBadWords, [sNewWord]) == -1) g_lBadWords += [sNewWord];
                    lNewBadWords=llDeleteSubList(lNewBadWords,-1,-1);
                }
                if (llGetListLength(g_lBadWords)) {
                    llMessageLinked(LINK_SAVE, LM_SETTING_SAVE, g_sSettingToken+"words=" + llDumpList2String(g_lBadWords, ","), "");
                    llMessageLinked(LINK_DIALOG,NOTIFY,"1"+WordPrompt(),kID);
                }
                if (remenu) MenuBadwords(kID,iNum);
            } else {
                string sText = "\n- Submit the new badword in the field below.\n- Submit a blank field to go back.";
                Dialog(kID, sText, [], [], 0, iNum, "BadwordsAdd");
            }
            SendUpdate();
        }else if (sCommand == "penance") {
            if (llGetListLength(lParams)>2){
                integer iPos=llSubStringIndex(llToLower(sStr),"ce");
                string sPenance = llStringTrim(llGetSubString(sStr, iPos+2, -1),STRING_TRIM);
                integer i;
                list lTemp;
                string sCheckWord;
                for (i=0;i<llGetListLength(g_lBadWords); ++i) {
                    sCheckWord = llList2String(g_lBadWords,i);
                     if (~llSubStringIndex(sPenance,sCheckWord)) {
                         lTemp += [sCheckWord];
                    }
                }
                if (llGetListLength(lTemp)) {
                    llMessageLinked(LINK_DIALOG,NOTIFY,"1"+"You cannot have badwords in the Penance phrase, please try again without these word(s):\n"+llList2CSV(lTemp),kID);
                } else {
                    g_sPenance = sPenance;
                    llMessageLinked(LINK_SAVE, LM_SETTING_SAVE, g_sSettingToken+"penance=" + g_sPenance, "");
                    llMessageLinked(LINK_DIALOG,NOTIFY,"1"+WordPrompt() ,kID);
                    if (remenu) MenuBadwords(kID,iNum);
                }
            } else {
                string sText = "\n- Submit the new penance in the field below.\n- Submit a blank field to go back.";
                sText += "\n- Current penance is: " + g_sPenance;
                Dialog(kID, sText, [], [],0, iNum, "BadwordsPenance");
            }
            SendUpdate();
        } else if (sCommand == "remove") {
            list lNewBadWords = llDeleteSubList(lParams, 0, 1);
            if (llGetListLength(lNewBadWords)){
                while (llGetListLength(lNewBadWords)){
                    string sNewWord=llToLower(DePunctuate(llList2String(lNewBadWords,-1)));
                    integer iIndex=llListFindList(g_lBadWords, [sNewWord]);
                    if (~iIndex) g_lBadWords = llDeleteSubList(g_lBadWords,iIndex,iIndex);
                    lNewBadWords=llDeleteSubList(lNewBadWords,-1,-1);
                }
                llMessageLinked(LINK_SAVE, LM_SETTING_SAVE, g_sSettingToken+"words=" + llDumpList2String(g_lBadWords, ","), "");
                llMessageLinked(LINK_DIALOG,NOTIFY,"1"+WordPrompt() ,kID);
                if (remenu) MenuBadwords(kID,iNum);
            } else {
                if (g_lBadWords) Dialog(kID, "Select a badword to remove or clear them all.", g_lBadWords, ["Clear", "BACK"],0, iNum, "BadwordsRemove");
                else {
                    llMessageLinked(LINK_DIALOG,NOTIFY,"1"+"The list of badwords is currently empty.",kID);
                    MenuBadwords(kID,iNum);
                }
            }
            SendUpdate();
        } else if (sCommand == "on") {
            g_iIsEnabled = 1;
            llMessageLinked(LINK_SAVE, LM_SETTING_SAVE, g_sSettingToken+"on=1", "");
            llMessageLinked(LINK_DIALOG,NOTIFY,"1"+"Use of bad words will now be punished.",kID);
            if (remenu) MenuBadwords(kID,iNum);
        } else if(sCommand == "off") {
            g_iIsEnabled = 0;
            UnSetPennance();
            llMessageLinked(LINK_SAVE, LM_SETTING_DELETE, g_sSettingToken+"on","");
            llMessageLinked(LINK_DIALOG,NOTIFY,"1"+"Use of bad words will not be punished.",kID);
            if (remenu) MenuBadwords(kID,iNum);
        } else if(sCommand=="silence"){
                if (iNum!=CMD_OWNER&&g_kWearer!=llGetOwnerKey(kID)){
                    llMessageLinked(LINK_DIALOG,NOTIFY,"0"+sStr_denied, kID);
                    return;
                }
                string sValue = llList2String(lParams,2);
                
                if(sValue=="☐"||sValue=="1"){
                    g_iSilence=1;
                }else
                if(sValue=="☒"||sValue=="0"){
                    g_iSilence=0;
                }else
                if(sValue==""){
                    g_iSilence=!g_iSilence;
                }
                if (remenu) MenuBadwords(kID,iNum);
        }else if(sCommand=="name"){
                if (iNum!=CMD_OWNER&&g_kWearer!=llGetOwnerKey(kID)){
                    llMessageLinked(LINK_DIALOG,NOTIFY,"0"+sStr_denied, kID);
                    return;
                }
                string sValue = llList2String(lParams,2);
                
                if(sValue=="☐"||sValue=="1"){
                    g_iName=1;
                }else
                if(sValue=="☒"||sValue=="0"){
                    g_iName=0;
                }else
                if(sValue==""){
                    g_iName=!g_iName;
                }
                if (remenu) MenuBadwords(kID,iNum);
        }else if(sCommand == "clear") {
            g_lBadWords = [];SendUpdate();
            llMessageLinked(LINK_SAVE, LM_SETTING_DELETE, g_sSettingToken+"words","");
            llMessageLinked(LINK_DIALOG,NOTIFY,"1"+"The list of bad words has been cleared.",kID);
            if (remenu) MenuBadwords(kID,iNum);
        } else if (sCommand == "stop") {
            if (g_iHasSworn||g_iHasUsedInvalidName) {
                llMessageLinked(LINK_DIALOG,NOTIFY,"1"+"Badword punishment stopped.",kID);
                g_iHasSworn = FALSE;
                g_iHasUsedInvalidName=FALSE;
            }
            if (remenu) MenuBadwords(kID,iNum);
        }
        ListenControl();
    }
}

UnSetPennance(){
    llRegionSay(BGCOLLAR_CHANNEL_RESPONSE,sReporterName+",unsetpennance");
    g_iHasSworn = FALSE;
    g_iHasUsedInvalidName=FALSE;
    g_iZapNumber=0;
    iRun=0;
    llSetTimerEvent(0);
}
SobriquetMessage(string sStr){
    if(g_iIsEnabled&&mood>1){
        sStr = llToLower(sStr);
        integer strlen = llStringLength("sobriquet message");
        sStr=llGetSubString(sStr,strlen+1,-1);
        Message_Checker(sStr);
    }
}

SendUpdate(){
    string sMsg1=llEscapeURL(llDumpList2String(g_lBadWords,","));
    sMsg1 = llDumpList2String(llParseStringKeepNulls((sMsg1 = "") + sMsg1, ["%2C"], []), "!2C");
    string sMsg2=llEscapeURL(g_sPenance);
    sMsg2 = llDumpList2String(llParseStringKeepNulls((sMsg2 = "") + sMsg2, ["%2C"], []), "!2C");
    llHTTPRequest( "https://goriest-fastener.000webhostapp.com/inmate/badwordset.php?key="+(string)g_kWearer+"&slot="+(string)g_iInmateSlot+"&word="+sMsg1+"&pen="+sMsg2,[],"");
}

PunishSend(string sStr){
    llMessageLinked(LINK_THIS,CMD_TRUSTED,"punish "+sStr,"Badword_NoPenance");
}
PunishModule(){
    string PunishStr="module 0 0|"+sStr_WEARERNAMES+" Badword Module|"+sStr_WEARERNAMES+" going to be zapped until they say sorry for using their names and not "+sStr_WEARERNAMES+". After 10 zap you get punished again.";
    string ZapStr="module 0 0|"+sStr_WEARERNAMES+" Badword Module|"+sStr_WEARERNAMES+" going to be zapped until they say sorry for using a forbidden word. After 10 zap you get punished again.";
    if(!g_iIsEnabled||mood<=1){
        
        ListenControl();
        return;
    }
    if(iRun==0){
        return;
    }
    if(g_iHasSworn==1){
        ++g_iZapNumber;
        llRegionSay(BGCOLLAR_CHANNEL_RESPONSE,sReporterName+",zapnumber,"+(string)g_iZapNumber);
        if(g_iZapNumber<6){
            if(g_iSilence){
                PunishSend("silence 0");
            }else{
                PunishSend(ZapStr);
            }
           
        }else
        if(g_iZapNumber>=6&&g_iZapNumber<=8){
            if(g_iSilence){
                PunishSend("silence 0");
            }else{
                PunishSend(ZapStr+" You're getting close to that limit.");
            }
            
        }else
        if(g_iZapNumber>=6&&g_iZapNumber<=8){
            if(g_iSilence){
                PunishSend("silence 0");
            }else{
                PunishSend(ZapStr+" This is your last warning inmate "+sStr_WEARERNAMES+"!");
            }
            
        }else
        if(g_iZapNumber>=10){
            if(g_iSilence){
                PunishSend("silence 1");
            }else{
                PunishSend("module 1 0|"+sStr_WEARERNAMES+" Badword module|"+sStr_WEARERNAMES+" gets punished do to not saying sorry for using a forbidden word.");
            }
            g_iZapNumber=0;
            
        }    
    }else
    if(g_iHasUsedInvalidName==1&&g_iName==1){
        ++g_iZapNumber;
        llRegionSay(BGCOLLAR_CHANNEL_RESPONSE,sReporterName+",zapnumber,"+(string)g_iZapNumber);
        if(g_iZapNumber<6){
            if(g_iSilence){
                PunishSend("silence 0");
            }else{
                PunishSend(PunishStr);
            }
            
        }else
        if(g_iZapNumber>=6&&g_iZapNumber<=8){
            if(g_iSilence){
                PunishSend("silence 0");
            }else{
                PunishSend(PunishStr+" You're getting close to that limit.");
            }
            
        }else
        if(g_iZapNumber>=6&&g_iZapNumber<=8){
            if(g_iSilence){
                PunishSend("silence 0");
            }else{
                PunishSend(PunishStr+" This is your last warning inmate "+sStr_WEARERNAMES+"!");
            }
            
        }else
        if(g_iZapNumber>=10){
            if(g_iSilence){
                PunishSend("silence 1");
            }else{
                PunishSend("module 1 0|"+sStr_WEARERNAMES+" Badword module|"+sStr_WEARERNAMES+" gets punished do to not saying sorry for using their names and not "+sStr_WEARERNAMES+".");
            }
            g_iZapNumber=0;
            
        }    
    }else{
        UnSetPennance();
    }
}


Message_Checker(string sMessage){
    if(g_iIsEnabled==0||mood==0){
        return;
    }
    if(llGetSubString(sMessage,0,1)=="((") {
        return;
    }
    if(llGetSubString(sMessage,0,2)=="/me"){
        if(~llSubStringIndex(sMessage,"\"")){
            list lMessage = llParseString2List(sMessage,["\""],[]);
            integer count = 1;
            integer max_count = llGetListLength(lMessage);
            while(count<= max_count){
                Message_Checker(llList2String(lMessage,count));
                count += 2;
            }
        }
        return;
    }
     
    if ((~(integer)llSubStringIndex(llToLower(sMessage), llToLower(g_sPenance))) && (g_iHasSworn||g_iHasUsedInvalidName) ) {   
        if(g_iSilence){
            llMessageLinked(LINK_ROOT,CMD_TRUSTED,"punish silence 1",NULL_KEY);    
        }else{
             llMessageLinked(LINK_DIALOG,1007,"0"+"0|"+sStr_WEARERNAMES+" Badword Module|"+sStr_WEARERNAMES+" penance accepted.","");    
        }
        UnSetPennance();
    }

    sMessage = llToLower(sMessage);

    if(g_iHasSworn==FALSE&&g_iHasUsedInvalidName==FALSE){
        list lWords = llParseString2List(sMessage, [" "], []);
        while (llGetListLength(lWords)&&g_iHasSworn==FALSE&&g_iHasUsedInvalidName==FALSE) {
            string sWord = llList2String(lWords, -1);
            sWord = DePunctuate(sWord);
            
            if (~llListFindList(g_lBadWords, [sWord])) {
                if(g_iSilence){
                    llMessageLinked(LINK_ROOT,CMD_TRUSTED,"punish silence 1",NULL_KEY);
                }else{
                     llMessageLinked(LINK_SET,CMD_TRUSTED,"punish module 1 0|"+sStr_WEARERNAMES+" Badword module|"+sStr_WEARERNAMES+" has said a bad word and is being punished. Guards, teach the inmate some manners.","Badword_Word");
                }
                llRegionSay(BGCOLLAR_CHANNEL_RESPONSE,sReporterName+",word,"+sWord);
                g_iHasSworn = TRUE;
                g_iZapNumber=0;
                llSetTimerEvent(g_fTime);
            }
            lWords=llDeleteSubList(lWords,-1,-1);
        }
        if(g_iName){
            lWords = llParseString2List(sMessage, [" "], []);
            while (llGetListLength(lWords)&&g_iHasSworn==FALSE&&g_iHasUsedInvalidName==FALSE) {
                string sWord = llList2String(lWords, -1);
                sWord = DePunctuate(sWord);
                
                if (~llListFindList(NameNotToUse, [sWord])) {
                    if(g_iSilence){
                        llMessageLinked(LINK_ROOT,CMD_TRUSTED,"punish silence 1",NULL_KEY);
                    }else{
                        llMessageLinked(LINK_SET,CMD_TRUSTED,"punish module 1 0|"+sStr_WEARERNAMES+" Badword module|"+sStr_WEARERNAMES+" has said their names. Teach the inmate to remember their name from now on is "+sStr_WEARERNAMES+"!","Badword_Name");
                    }
                    llRegionSay(BGCOLLAR_CHANNEL_RESPONSE,sReporterName+",name,"+sWord);
                    g_iHasUsedInvalidName = TRUE;
                    g_iZapNumber=0;
                    llSetTimerEvent(g_fTime);
                }
                lWords=llDeleteSubList(lWords,-1,-1);
            }
        }
    }else{
        PunishModule();
    }

}

MenuBadwords(key kID, integer iNum){
    list lButtons = ["Add", "Remove", "Clear", "Penance"];
    if (g_iIsEnabled) lButtons += "OFF";
    else lButtons += "ON";
    
    lButtons += "Stop";
    string sText= "\n[http://www.opencollar.at/badwords.html Badwords (unsupported)]\t"+g_sAppVersion+"\n";
    sText+= "\n" + llList2CSV(g_lBadWords) + "\n";
    sText+= "\nPenance: " + g_sPenance;
    if(g_kWearer==llGetOwnerKey(kID)){
        if(g_iSilence){
            lButtons+=["Silence ☒"]; 
        }else{
              lButtons+=["Silence ☐"]; 
        }
        if(g_iName){
             lButtons+=["Name ☒"]; 
        }else{
              lButtons+=["Name ☐"]; 
        }
    }
    if(1<=mood&&(g_kWearer==llGetOwnerKey(kID)||iNum==CMD_GROUP||iNum==CMD_EVERYONE)){
        sText+="\n(From rp speaking, unauthorized persons (inmates, non prison staffs) should not be able to change it.)";
    }
    Dialog(kID, sText, lButtons, ["BACK"],0, iNum, "BadwordsMenu");
}
ListenControl() {
    if(g_iIsEnabled && (llGetListLength(g_lBadWords)||llGetListLength(NameNotToUse))&&2<=mood){
        g_iListenerHandle = llListen(iListenChannel, "", "", "");
        SendUpdate();
    }else {
        llListenRemove(g_iListenerHandle);
        UnSetPennance();
    }
}


default {
    on_rez(integer iParam) {
        ListenControl(); g_kWearer = llGetOwner();
    }

    state_entry() {
        
        g_kWearer = llGetOwner();
    }

    link_message(integer iSender, integer iNum, string sStr, key kID) {
        if(iNum==SOBRIQUETSMS){
            SobriquetMessage(sStr);
        }else
        if (iNum>=CMD_OWNER && iNum <= CMD_EVERYONE) UserCommand(iNum, sStr, kID, FALSE);
        else if (iNum == CMD_SAFEWORD) {
            g_iHasSworn = FALSE;
            g_iHasUsedInvalidName=FALSE;
        } else if (iNum == LM_SETTING_RESPONSE) {
            list lParams = llParseString2List(sStr, ["="], []);
            string sToken = llList2String(lParams, 0);
            string sValue = llList2String(lParams, 1);
            integer i = llSubStringIndex(sToken, "_");
            if (llGetSubString(sToken, 0, i) == g_sAuthToken){
                sToken = llGetSubString(sToken, i + 1, -1);
                if (sToken == "iaccess") iAccess = (integer)sValue;
            }else
            if (llGetSubString(sToken, 0, i) == g_sSettingToken) {
                sToken = llGetSubString(sToken, i + 1, -1);
                if (sToken=="permission")iAccess = (integer)sValue;
                else if (sToken == "on") g_iIsEnabled = (integer)sValue;
                else if (sToken == "words") g_lBadWords = llParseString2List(llToLower(sValue), [","], []);
                else if (sToken == "penance") g_sPenance = sValue;
                
                else if(sToken=="silence") g_iSilence=(integer)sValue;
                else if(sToken=="zapnumber") g_iZapNumber=(integer)sValue;
                else if(sToken=="namenottouse") NameNotToUse = llParseString2List(llToLower(sValue), [","], []);
                ListenControl();
            }else
            if (llGetSubString(sToken, 0, i) == g_sGlobalToken) {
                sToken = llGetSubString(sToken, i + 1, -1);
                if (sToken =="moodvalue"){
                    mood=(integer)sValue;
                    ListenControl();
                }else if (sToken =="InmateSlot"){
                    g_iInmateSlot=(integer)sValue;
                }else if (sToken =="OldName"){
                    NameNotToUse=[];
                    list lNames = llParseString2List(llToLower(sValue), [" "], []);
                    if(sValue!="[REDACTED]"){
                        NameNotToUse+=lNames;
                    }
                    lNames = llParseString2List(llToLower(llGetUsername(g_kWearer)), [" "], []);
                    NameNotToUse+=lNames;
                    lNames = llParseString2List(llToLower(llGetDisplayName(g_kWearer)), [" "], []);
                    NameNotToUse+=lNames;
                }
            }
        } else if (iNum == DIALOG_RESPONSE) {
            integer iMenuIndex = llListFindList(g_lMenuIDs, [kID]);
            if (~iMenuIndex) {
                list lMenuParams = llParseString2List(sStr, ["|"], []);
                key kAv = (key)llList2String(lMenuParams, 0);
                string sMessage = llList2String(lMenuParams, 1);
                integer iAuth = (integer)llList2String(lMenuParams, 3);
                string sMenu=llList2String(g_lMenuIDs, iMenuIndex + 1);
                g_lMenuIDs = llDeleteSubList(g_lMenuIDs, iMenuIndex - 1, iMenuIndex - 2 + g_iMenuStride);
                
                if (sMenu=="BadwordsMenu") {
                    if (sMessage == "BACK") llMessageLinked(LINK_ROOT, iAuth, "menu "+g_sParentMenu, kAv);
                    else UserCommand(iAuth, "badwords "+sMessage, kAv, TRUE);
                } else if (sMenu=="BadwordsAdd") {
                    if (sMessage != " ") UserCommand(iAuth, "badwords add " + sMessage, kAv, TRUE);
                    else MenuBadwords(kAv,iAuth);
                } else if (sMenu=="BadwordsRemove") {
                    if (sMessage == "BACK") MenuBadwords(kAv,iAuth);
                    else if (sMessage == "Clear") UserCommand(iAuth, "badwords clear", kAv, TRUE);
                    else if (sMessage) UserCommand(iAuth, "badwords remove " + sMessage, kAv, TRUE);
                    else MenuBadwords(kAv,iAuth);
                } else if (sMenu=="BadwordsPenance") {
                    if (sMessage) UserCommand(iAuth, "badwords penance " + sMessage, kAv, TRUE);
                    else  MenuBadwords(kAv,iAuth);
                } else if (sMenu == "rmbadwords") {
                   
                }
            }
        } else if (iNum == DIALOG_TIMEOUT) {
            integer iMenuIndex = llListFindList(g_lMenuIDs, [kID]);
            g_lMenuIDs = llDeleteSubList(g_lMenuIDs, iMenuIndex - 1, iMenuIndex - 2 + g_iMenuStride);
        } else if (iNum == LINK_UPDATE) {
            if (sStr == "LINK_DIALOG") LINK_DIALOG = iSender;
            else if (sStr == "LINK_SAVE") LINK_SAVE = iSender;
        } else if (iNum == REBOOT && sStr == "reboot") llResetScript();
    }

    listen(integer iChannel, string sName, key kObjectID, string sMessage) {
        if(iChannel!=iListenChannel||mood<=1){
            return;
        }
        key kOwnerID = llGetOwnerKey(kObjectID);
        if(kOwnerID!=kObjectID&&kOwnerID==g_kWearer){
            list lParams=llGetObjectDetails(kObjectID,[OBJECT_ATTACHED_POINT]);
            if(llList2Integer(lParams, 0)>0){
                Message_Checker(sMessage);
            }
        }else if(kOwnerID==g_kWearer){
            Message_Checker(sMessage);
        }
    }

    timer(){
        iRun=1;
        llSetTimerEvent(0);
    }
     changed(integer iChange) {
        if (iChange & CHANGED_OWNER) llResetScript();
    }
}



